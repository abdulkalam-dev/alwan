{"version":3,"file":"js/alwan.min.js","mappings":"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","sources":["webpack://Alwan/webpack/universalModuleDefinition","webpack://Alwan/webpack/bootstrap","webpack://Alwan/webpack/runtime/define property getters","webpack://Alwan/webpack/runtime/hasOwnProperty shorthand","webpack://Alwan/./src/js/constants.js","webpack://Alwan/./src/js/utils/object.js","webpack://Alwan/./src/js/utils/util.js","webpack://Alwan/./src/js/utils/dom.js","webpack://Alwan/./src/js/core/events/EventBinder.js","webpack://Alwan/./src/js/lib/popper.js","webpack://Alwan/./src/js/components/App.js","webpack://Alwan/./src/js/lib/svg.js","webpack://Alwan/./src/js/components/Palette.js","webpack://Alwan/./src/js/components/Marker.js","webpack://Alwan/./src/js/lib/colors.js","webpack://Alwan/./src/js/lib/parser.js","webpack://Alwan/./src/js/core/index.js","webpack://Alwan/./src/js/components/Reference.js","webpack://Alwan/./src/js/components/Preview.js","webpack://Alwan/./src/js/components/Sliders.js","webpack://Alwan/./src/js/components/Inputs.js","webpack://Alwan/./src/js/components/Swatches.js","webpack://Alwan/./src/js/core/colorState.js","webpack://Alwan/./src/js/index.js","webpack://Alwan/./src/js/core/events/EventListener.js","webpack://Alwan/./src/js/defaults.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Alwan\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Alwan\"] = factory();\n\telse\n\t\troot[\"Alwan\"] = factory();\n})(self, function() {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","export const ROOT = document;\nexport const HTML = ROOT.documentElement;\n\nexport const BUTTON = 'button';\nexport const SVG = 'svg';\n\nexport const OPEN = 'open';\nexport const CLOSE = 'close';\nexport const COLOR = 'color';\nexport const CLICK = 'click';\nexport const MOUSE_DOWN = 'mousedown';\nexport const MOUSE_MOVE = 'mousemove';\nexport const MOUSE_UP = 'mouseup';\nexport const TOUCH_START = 'touchstart';\nexport const TOUCH_MOVE = 'touchmove';\nexport const TOUCH_END = 'touchend';\nexport const TOUCH_CANCEL = 'touchcancel';\nexport const SCROLL = 'scroll';\nexport const RESIZE = 'resize';\nexport const KEY_DOWN = 'keydown';\nexport const INPUT = 'input';\nexport const CHANGE = 'change';\nexport const MOUSE_LEAVE = 'mouseleave';\nexport const FOCUS_IN = 'focusin';\nexport const FOCUS_OUT = 'focusout';\n\nexport const HEX_FORMAT = 'hex';\nexport const RGB_FORMAT = 'rgb';\nexport const HSL_FORMAT = 'hsl';\nexport const HSV_FORMAT = 'hsv';\n\nexport const TAB = 'Tab';\nexport const ARROW_RIGHT = 'ArrowRight';\nexport const ARROW_LEFT = 'ArrowLeft';\nexport const ARROW_UP = 'ArrowUp';\nexport const ARROW_DOWN = 'ArrowDown';\nexport const ENTER = 'Enter';\nexport const ESCAPE = 'Escape';\n\nexport const FOCUS_CLASSNAME = 'lw-focus';\nexport const BUTTON_CLASSNAME = 'lw-btn';\n\nexport const COLOR_PROPERTY = 'lw-' + COLOR;\n\nexport const REMOVE_METHOD = 'remove';\nexport const ADD_METHOD = 'add';\n\n// Picker supported color formats.\nexport const COLOR_FORMATS = [HEX_FORMAT, RGB_FORMAT, HSL_FORMAT];\n\n\nexport const { max, min, round, abs } = Math;\nexport const float = parseFloat;\nexport const int = parseInt;","/**\n * Iterate in an object, stop and return false if callback function returns true.\n *\n * @param {Object} object - Any object.\n * @param {CallableFunction} fn - Any Callback function.\n * @returns {Boolean}\n */\nexport const objectIterator = (object, fn) => {\n\n    for (const key in object) {\n        if (Object.hasOwnProperty.call(object, key)) {\n            if (fn(object[key], key, object)) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n\n\n/**\n * Merges two or more objects together into the target object.\n *\n * @param {Object} target - Object that will receive the new properties.\n * @param  {...Object} sources - Objects containing additional properties to merge in.\n * @returns {Object}\n */\nexport const merge = (target, ...sources) => Object.assign(target, ...sources);\n\n/**\n * Checks if two object are equals.\n *\n * @param {Object} object1 - Any object.\n * @param {Object} object2 - Any object.\n * @returns {Boolean}\n */\nexport const isEqual = (object1, object2) => objectIterator(object1, (value, key) => !object2 || object2[key] !== value);\n","import { CHANGE, COLOR, max, min, round } from \"../constants\";\n\n/**\n * Checks if a value is a string.\n *\n * @param {Any} value - Value.\n * @returns {Boolean}\n */\nexport const isString = value => typeof value === 'string';\n\n/**\n * Checks if a value is not undefined or null.\n *\n * @param {Any} value - Value.\n * @returns {Boolean}\n */\nexport const isset = value => value != null;\n\n\n/**\n * Bounds a number between a lower bound and an upper bound.\n *\n * @param {number} number - Any number.\n * @param {number} upperBound - Max.\n * @param {number} lowerBound - Min.\n * @returns {number}\n */\nexport const boundNumber = (number, upperBound, lowerBound) => min(max(number, lowerBound || 0), upperBound || 100);\n\n\n/**\n * Sets color, if color state changes then trigger color and change events.\n *\n * @param {Object} alwan - Instance.\n * @param {String} color - Color.\n * @param {Element|Object} source - Event source.\n */\nexport const setColorAndTriggerEvents = (alwan, color, source) => {\n    if (alwan._s._updateFromString(color, true)) {\n        let emit = alwan._e._emit;\n        emit(COLOR, source);\n        emit(CHANGE, source);\n    }\n}\n\n/**\n * Hue value is an angle in degrees, it must be between 0 and 360.\n *\n * @param {Number} hue - Color hue.\n * @returns {Number}\n */\nexport const normalizeHue = hue => (round(hue) % 360 + 360) % 360;","import { ADD_METHOD, REMOVE_METHOD, ROOT, SCROLL, SVG } from \"../constants\";\nimport { objectIterator } from \"./object\";\nimport { isString } from \"./util\";\n\n/**\n * Gets a DOM element.\n *\n * @param {String|Element} ref - CSS selector or DOM element.\n * @param {Element} context - Element to search from.\n * @param {Boolean} all - Get all elements.\n * @returns {Element|null}\n */\nexport const getElement = (ref, context, all) =>\n    isString(ref) ? ref && (context || ROOT)['querySelector' + (all ? 'All' : '')](ref)\n        : ref instanceof Element ? ref\n        : null;\n\n/**\n * Creates a new HTML Element.\n *\n * @param {String}           tagName     - HTML Element's Tag name.\n * @param {String}           className   - HTML Element's class name.\n * @param {Element}          parent - Append the new created element to this element.\n * @param {Object}           data - New element data its attributes, content html or inner text.\n * @param {CallableFunction} callback - Callback.\n * @returns {Element}\n */\nexport const createElement = (tagName, className, parent, data, callback) => {\n\n    data = data || {}\n    const ns = `http://www.w3.org/${tagName === SVG ? '2000/svg' : '1999/xhtml'}`;\n    const element = document.createElementNS(ns, tagName || 'div');\n\n    if (className) {\n        element.className = className;\n    }\n\n    objectIterator(data, (value, key) => {\n        if (key === 'html') {\n            setElementsHTML(element, value);\n        } else if (key === 'text') {\n            element.innerText = value;\n        } else {\n            value && element.setAttributeNS('', key, value);\n        }\n    });\n\n    if (parent) {\n        parent.appendChild(element);\n    }\n\n    callback && callback(element);\n\n    return element;\n}\n\n\n/**\n * Gets element bounds.\n *\n * @param {HTMLElement} el Element.\n * @returns {Object}\n */\nexport const getBounds = (el) => el && el.getBoundingClientRect();\n\n\n/**\n * Gets an element's parent.\n *\n * @param {Element} el - Any html element.\n * @returns {Element}\n */\nexport const getParent = el => el.parentElement;\n\n\n/**\n * Replace a child node with another node.\n *\n * @param {Node} newChild - Any html node.\n * @param {Node} oldChild - Any html node.\n * @returns {Node}\n */\nexport const replaceElement = (newChild, oldChild) => getParent(oldChild).replaceChild(newChild, oldChild) && newChild;\n\n/**\n * Removes an element from the DOM.\n *\n * @param {HTMLElement} element - Any html node.\n * @param {Boolean} destroy - Remove Reference. \n * @returns {Element|null}\n */\nexport const removeElement = (element, destroy) => element && getParent(element).removeChild(element) && (destroy ? null : element);\n\n\n/**\n * Gets any scrollable ancestor of an element.\n * Document is always included.\n *\n * @param {HTMLElement} el - Subject element.\n * @returns {Array}\n */\nexport const getScrollableAncestors = el => {\n    el = getParent(el);\n  \n    let scrollableElements = [ROOT];\n  \n    while (el !== ROOT.body) {\n      let overflow = getComputedStyle(el).overflow;\n      if (overflow === 'auto' || overflow === SCROLL) {\n        scrollableElements.push(el);\n      }\n      el = getParent(el);\n    }\n  \n    return scrollableElements;\n}\n\n\n/**\n * Check if an element is visible in the viewport of all scrollable elements.\n *\n * @param {HTMLElement} el - Any html element.\n * @param {Array} scrollableElements - scrollable elements.\n * @returns {boolean}\n */\nexport const isInViewport = (el, scrollableElements) =>\n    scrollableElements.every(scrollable => {\n        let isVisible = true;\n\n        if (scrollable !== ROOT) {\n            let {top: elTop, bottom: elBottom} = getBounds(el);\n            let {top: scrollableTop, bottom: scrollableBottom} = getBounds(scrollable);\n\n            isVisible = elTop >= scrollableTop && scrollableBottom >= elBottom;\n        }\n\n        return isVisible;\n    });\n\n\n/**\n * Sets a CSS custom property.\n *\n * @param {HTMLElement} el  - Element to set its custom property.\n * @param {string} property - Property name.\n * @param {string} value    - Property value.\n */\nexport const setCustomProperty = (el, property, value) => {\n    el && el.style.setProperty('--' + property, value);\n}\n\n\n/**\n * Hides/Shows element.\n * Truthy value or non empty array shows the element,\n * else hides it.\n * \n * @param {Element} el - Element to show/hide.\n * @param {Array|Boolean} cond - Condition.\n */\nexport const setVisibility = (el, cond) => {\n\n    let length = cond && cond.length;\n\n    if (length != null) {\n        cond = length;\n    }\n\n    el.style.display = cond ? '' : 'none';\n}\n\n/**\n * Adds/Remove class based on a condition.\n *\n * @param {Element} el - Any Element.\n * @param {String} classname - CSS Class Selector.\n * @param {Boolean} cond - Condition.\n */\nexport const updateClass = (el, classname, cond) => {\n    classname && el.classList[cond ? ADD_METHOD : REMOVE_METHOD](classname);\n}\n\n/**\n * Sets element's inner html.\n *\n * @param {Element} el - Any Element.\n * @param {String} html - HTML string.\n */\nexport const setElementsHTML = (el, html) => {\n    el.innerHTML = html || '';\n}","import { ADD_METHOD, REMOVE_METHOD } from \"../../constants\";\nimport { isString } from \"../../utils/util\";\n\n/**\n * Adds/Removes one or more event listeners to/from an element.\n *\n * @param {targetElement} targetElement - Event target element.\n * @param {Array} eventData - Event data (type, handler, options).\n * @param {String} method - Add or Remove event listener method.\n */\nexport const binder = (eventData, unbind) => {\n\n    let method = (unbind ? REMOVE_METHOD: ADD_METHOD) + 'EventListener';\n    let [targetElement, events, handler, options] = eventData;\n\n    // If its a single event then put it inside an array.\n    if (isString(events)) {\n        events = [events];\n    }\n\n    events.forEach(event => {\n        targetElement[method](event, handler, options);\n    });\n}\n\n/**\n * Binds events to an element and stores listener in an array.\n *\n * @param {Array} listeners - Event Listeners.\n * @param {targetElement} targetElement - Event Target.\n * @param {String|Array} events - Event type.\n * @param {CallableFunction} handler - Event handler.\n * @param {Object|Boolean} options - Event options.\n * @returns {Array}\n */\nexport const bindEvent = (listeners, targetElement, events, handler, options) => {\n\n    if (targetElement) {\n        options = options || false;\n        let eventData = [targetElement, events, handler, options];\n        binder(eventData);\n        listeners.push(eventData);\n    }\n\n    return listeners;\n}\n\n/**\n * Unbinds all listeners attach to an element and removes them from listeners array.\n *\n * @param {Array} listeners - Event listeners.\n * @param {targetElement} targetElement - Event Target.\n * @returns {Array}\n */\nexport const unbindEvent = (listeners, targetElement) =>\n    // Filter out listeners attached to this TargetElement.\n    listeners.filter(eventData => \n        targetElement === eventData[0] ? \n            binder(eventData, true)\n            : true\n    );","import { abs, float, HTML } from \"../constants\";\nimport { getBounds } from \"../utils/dom\";\n\n/**\n * Constants\n */\nconst TOP = 'top';\nconst RIGHT = 'right';\nconst BOTTOM = 'bottom';\nconst LEFT = 'left';\nconst START = 'start';\nconst CENTER = 'center';\nconst END = 'end';\nconst WIDTH = 'width';\nconst HEIGHT = 'height';\n\n/**\n * Display an element as a popover.\n *\n * @param {Element} ref - Popper reference element.\n * @param {Element} pop - Popper element.\n * @param {Object} options - Options.\n * @returns {Object}\n */\nexport const Popper = (ref, pop, options) => {\n\n    options = options || {};\n\n    /**\n     * Popper options.\n     */\n    let { margin, position } = options;\n\n    /**\n     * Position is devided into, side and alignment.\n     */\n    let [side, alignment] = position ? position.split('-') : [];\n\n    /**\n     * Sides to fallback to.\n     */\n    let sides = {\n        [TOP]: [TOP, BOTTOM, RIGHT, LEFT],\n        [BOTTOM]: [BOTTOM, TOP, RIGHT, LEFT],\n        [RIGHT]: [RIGHT, LEFT, TOP, BOTTOM],\n        [LEFT]: [LEFT, RIGHT, TOP, BOTTOM],\n    }\n\n    /**\n     * Alignments to fallback to.\n     */\n    let alignments = {\n        [START]: [START, CENTER, END],\n        [CENTER]: [CENTER, START, END],\n        [END]: [END, CENTER, START],\n    };\n\n    /**\n     * Document bounds.\n     *\n     * @type {object}\n     */\n    let domBounds;\n\n    /**\n     * Reference element bounds.\n     *\n     * @type {object}\n     */\n    let refBoundingRect;\n\n    /**\n     * Pop element bounds.\n     *\n     * @type {object}\n     */\n    let popBoundingRect;\n\n    // Normalize options values.\n    margin = margin == null ? 6 : float(margin);\n    side = sides[side] ? side : BOTTOM;\n    alignment = alignment ? alignments[alignment] ? alignment : START : CENTER;\n\n\n    /**\n     * Sets popper's position.\n     *\n     * @param {Boolean} isVertical - Indicate whether the popper is displayed on the Y axes.\n     * @param {Number} value - Value of the top or left css property.\n     */\n    const setPosition = (isVertical, value) => {\n        if (value !== false) {\n            pop.style[isVertical ? TOP : LEFT] = value + 'px';\n        }\n    }\n\n    /**\n     * Positions the popper in the screen center vertically or horizontally.\n     *\n     * @param {Boolean} isVertical - Indicate whether the popper is displayed on the Y axes.\n     */\n    const centerPopElement = (isVertical) => {\n        let dimension = WIDTH;\n        let maxBoundary = RIGHT;\n    \n        if (isVertical) {\n            dimension = HEIGHT;\n            maxBoundary = BOTTOM;\n        }\n\n        setPosition(isVertical, (domBounds[maxBoundary] - popBoundingRect[dimension]) / 2);\n    }\n\n    /**\n     * Updates popper's position.\n     */\n    const _update = () => {\n        domBounds = {\n            top: 0,\n            left: 0,\n            right: HTML.clientWidth,\n            bottom: HTML.clientHeight\n        }\n\n        refBoundingRect = getBounds(ref);\n        popBoundingRect = getBounds(pop);\n\n        let isPopPlaced = sides[side].some(side => {\n\n            let isVertical = side === TOP || side === BOTTOM;\n            let domBoundary = domBounds[side];\n            let refBound = refBoundingRect[side];\n            // Space taken by the pop element.\n            let space = margin + popBoundingRect[isVertical ? HEIGHT : WIDTH];\n            let hasSpace = space <= abs(domBoundary - refBound);\n\n            if (hasSpace) {\n                setPosition(isVertical, refBound + (domBoundary ? margin : -space));\n\n                // The pop element is positioned in the one of the 4 sides,\n                // Now its alignment.\n                let isPopAligned = alignments[alignment].some(alignment => {\n\n                    let dimension = HEIGHT;\n                    let lowerBound = TOP;\n                    let upperBound = BOTTOM;\n\n                    if (isVertical) {\n                        dimension = WIDTH;\n                        lowerBound = LEFT;\n                        upperBound = RIGHT;\n                    }\n                    // Reference lower bound top or left.\n                    let refLowerBound = refBoundingRect[lowerBound];\n                    // Reference upper bound bottom or right.\n                    let refUpperBound = refBoundingRect[upperBound];\n\n                    // Space between the document lower bound (top or left) and,\n                    // the reference upper bound (bottom or right).\n                    let lowerSpace = abs(domBounds[lowerBound] - refUpperBound);\n                    // Space between the document upper bound (bottom or right) and,\n                    // the reference lower bound (top or left).\n                    let upperSpace = abs(domBounds[upperBound] - refLowerBound);\n\n                    // Dimension could be height or width.\n                    let refDimension = refBoundingRect[dimension];\n                    let popDimension = popBoundingRect[dimension];\n\n                    // Center align pop element with the reference,\n                    // this is the distance between (lower/upper) bound of the reference,\n                    // and the (lower/upper) bound of the pop element.\n                    let offset = (popDimension + refDimension) / 2;\n\n                    // Check the space and get the position value in pixels.\n                    let placement = {\n                        [START]: popDimension <= upperSpace && refLowerBound,\n                        [CENTER]: offset <= lowerSpace && offset <= upperSpace && refUpperBound - offset,\n                        [END]: popDimension <= lowerSpace && refUpperBound - popDimension,\n                    }\n\n                    placement = placement[alignment];\n                    setPosition(! isVertical, placement);\n                    return placement !== false;\n                });\n\n                if (! isPopAligned) {\n                    centerPopElement(! isVertical);\n                }\n            }\n\n            return hasSpace;\n        });\n\n        if (! isPopPlaced) {\n            centerPopElement(true);\n            centerPopElement();\n        }\n    }\n\n    _update();\n\n    return {\n        _update\n    }\n}","import { BUTTON, CLOSE, ESCAPE, INPUT, KEY_DOWN, MOUSE_DOWN, OPEN, RESIZE, ROOT, SCROLL, TAB } from \"../constants\";\nimport { bindEvent, unbindEvent } from \"../core/events/EventBinder\";\nimport { Popper } from \"../lib/popper\";\nimport { createElement, getElement, getScrollableAncestors, isInViewport, setVisibility, updateClass } from \"../utils/dom\";\nimport { merge, objectIterator } from \"../utils/object\";\nimport { setColorAndTriggerEvents } from \"../utils/util\";\n/**\n * App component constants.\n */\nconst ALWAN_CLASSNAME = 'alwan';\nconst POPPER_CLASSNAME = 'lw-popper';\nconst DISABLED_CLASSNAME = 'lw-disabled';\n\n\n/**\n * App component.\n *\n * @param {Object} alwan - Alwan Instance.\n * @returns {Object}\n */\nexport const App = (alwan) => {\n\n    let { config, _e: { _emit }, _s: colorState } = alwan;\n\n    /**\n     * Top container.\n     *\n     * @type {HTMLElement}\n     */\n    let root = createElement('', ALWAN_CLASSNAME, ROOT.body);\n\n    /**\n     * Picker Reference.\n     *\n     * @type {Element}\n     */\n    let reference;\n\n    /**\n     * App API.\n     */\n    let self = {\n        e: []\n    }\n\n    /**\n     * Picker visibility state.\n     */\n    let isOpen = false;\n\n    /**\n     * Reference element scrollable ancestors.\n     *\n     * @type {Array<Element>}\n     */\n    let scrollableAncestors = [];\n\n    /**\n     * Popper object.\n     *\n     * @type {Object}\n     */\n    let popper;\n\n    /**\n     * Last focusable element in picker.\n     * \n     * @type {Element}\n     */\n    let lastFocusableElement;\n\n    /**\n     * Initialize app.\n     *\n     * @param {Object} options - Alwan options.\n     */\n    const _setup = (options) => {\n        options = options || {};\n\n        let config = merge(alwan.config, options);\n        let { theme, popover, target, position, margin, disabled, id, toggle } = config;\n        let targetElement = getElement(target);\n        let color = options.color;\n        let targetReference;\n\n        if (id) {\n            root.id = id;\n        }\n\n        /**\n         * Initialize components.\n         */\n        objectIterator(alwan._c, component => {\n            let init = component._init;\n            if (init) {\n                init(config);\n            }\n        });\n\n        /**\n         * Initialize color.\n         */\n        if (color) {\n            setColorAndTriggerEvents(alwan, color);\n        }\n\n        reference = alwan._c.ref.$;\n        targetReference = targetElement || reference;\n\n        // Remove all popper events.\n        popperEvents(unbindEvent);\n\n        /**\n         * Set disable.\n         */\n        _setDisable(disabled);\n\n        /**\n         * Set Theme.\n         */\n        root.dataset.theme = theme;\n\n        // Toggle option is false, picker is always open.\n        if (! toggle) {\n            _open(true);\n        }\n\n        // Hide reference if both popover and toggle are false.\n        setVisibility(reference, popover || toggle);\n\n        /**\n         * Set Popper.\n         */\n        if (popover) {\n            popper = Popper(targetReference, root, {\n                position,\n                margin\n            });\n            // If reference element inside a nested scrollable elements,\n            // get all those scrollable elements in an array.\n            scrollableAncestors = getScrollableAncestors(reference);\n\n            // Attach scroll event to all scrollable ancestors of the reference element,\n            // in order to update the popper's position.\n            // On window resize reposition the popper.\n            popperEvents(bindEvent);\n        } else {\n            targetReference.insertAdjacentElement( (targetElement ? 'before' : 'after') + 'end', root);\n        }\n        // If it's popover then the method will be 'add', if it's not,\n        // then the method will be 'remove'.\n        updateClass(root, POPPER_CLASSNAME, popover);\n\n        lastFocusableElement = getElement(BUTTON + ',' + INPUT, root, true);\n        lastFocusableElement = lastFocusableElement[lastFocusableElement.length - 1];\n    }\n\n\n    /**\n     * Update popper's position.\n     *\n     * @param {Event} e - Scroll or Resize event.\n     */\n    const updatePopper = e => {\n        if (isOpen) {\n            _reposition();\n\n            // Close picker if the reference element is not visible in the viewport,\n            // of nested scrollable elements.\n            if (! isInViewport(reference, scrollableAncestors)) {\n                _close(true);\n            }\n        }\n    }\n\n    /**\n     * Binds/Unbinds events for updating the popper's position.\n     *\n     * @param {Function} eventBinder - Bind/Unbind events.\n     */\n    const popperEvents = (eventBinder) => {\n        let listeners = self.e;\n\n        scrollableAncestors.forEach(scrollable => {\n            listeners = eventBinder(listeners, scrollable, SCROLL, updatePopper);\n        });\n\n        // On window resize reposition the popper.\n        listeners = eventBinder(listeners, window, RESIZE, updatePopper);\n        listeners = eventBinder(listeners, ROOT, [MOUSE_DOWN, KEY_DOWN], handlesAccessibility);\n\n        self.e = listeners;\n    }\n\n    /**\n     * Hanldes accessibility.\n     * \n     * If picker is displayed as a popover,\n     * send focus from reference element to the picker and vice versa,\n     * close picker on Escape key press or click away from the picker or the reference element.\n     *\n     * @param {Event}\n     */\n    const handlesAccessibility = e => {\n\n        if (isOpen) {\n            let { target, type, key, shiftKey } = e;\n            let palette = alwan._c.palette.$;\n            let elementToFocus;\n            // Clicking outside the picker or pressing Escape key, results in,\n            // closing the picker.\n            if (key === ESCAPE || (type === MOUSE_DOWN && reference !== target && ! root.contains(target))) {\n                _close();\n            } else if (key === TAB) {\n                // Pressing Tab on reference element sends focus to the picker palette.\n                if (target === reference && !shiftKey) {\n                    elementToFocus = palette;\n                // If picker is displayed as a popover,\n                // Pressing Tab + shift on the palette,\n                // or pressing Tab on the last focusable element in the picker,\n                // sends the focus back to the reference element.\n                } else if ((! shiftKey && target === lastFocusableElement) || (target === palette && shiftKey)) {\n                    elementToFocus = reference;\n                }\n\n                if (elementToFocus) {\n                    e.preventDefault();\n                    elementToFocus.focus();\n                }\n            }\n        }\n    }\n\n\n    /**\n     * Repositions the popper.\n     */\n    const _reposition = () => {\n        popper && popper._update();\n    }\n\n\n    /**\n     * Opens the color picker.\n     *\n     * @param {Boolean} silent - Whether to trigger the open event or not.\n     */\n    const _open = (silent) => {\n        if (! isOpen && ! config.disabled) {\n            // Update inputs.\n            colorState._update({}, true);\n            _reposition();\n            // Add open class.\n            updateClass(root, OPEN, true);\n            isOpen = true;\n            ! silent && _emit(OPEN);\n        }\n    }\n\n    /**\n     * Closes the color picker.\n     *\n     * @param {Boolean} silent - Whether to trigger the close event or not.\n     */\n    const _close = (silent) => {\n        if (isOpen && config.toggle) {\n            // Remove open class.\n            updateClass(root, OPEN, false);\n            isOpen = false;\n            ! silent && _emit(CLOSE);\n        }\n    }\n\n    /**\n     * Toggles (opens/closes) the color picker.\n     */\n    const _toggle = () => {\n        isOpen ? _close() : _open();\n    }\n\n    /**\n     * Gets the state of the picker, opened or closed.\n     *\n     * @returns {Boolean}\n     */\n    const _isOpen = () => isOpen;\n\n    /**\n     * Disable/Enable Picker.\n     *\n     * @param {Boolean} state - Picker state disabled (true) or enabled (false).\n     */\n    const _setDisable = state => {\n        config.disabled = state;\n        state && _close(true);\n        // Add/Remove disable class.\n        updateClass(reference, DISABLED_CLASSNAME, state);\n    }\n\n    return merge(self, {\n        $: root,\n        _setup,\n        _isOpen,\n        _open,\n        _close,\n        _toggle,\n        _setDisable,\n        _reposition,\n    });\n}\n","import { merge } from \"../utils/object\";\n\n/**\n * SVG attributes that are static for all SVGs.\n */\nconst staticAttrs = {\n    'aria-role': 'none',\n    focusable: 'false'\n}\n\nconst clipboardSVG = '<path d=\"M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z\"></path>';\nconst checkSVG = '<path d=\"M9,20.42L2.79,14.21L5.62,11.38L9,14.77L18.88,4.88L21.71,7.71L9,20.42Z\"></path>';\nconst switchSVG = '<path d=\"M10 1L5 8h10l-5-7zm0 18l5-7H5l5 7z\"></path>';\n\n/**\n * Gets SVG attributes object.\n *\n * @param {String} width - SVG Width.\n * @param {String} height - SVG Height.\n * @param {String} viewBox - SVG ViewBox.\n * @param {String} html - SVG Content.\n * @returns {Object}\n */\nconst svgAttrs = (width, height, viewBox, html) => ({ width, height, viewBox, html });\n\n\nexport const clipboardSVGAttrs = merge(svgAttrs('18', '18', '0 0 24 24', clipboardSVG), staticAttrs);\nexport const checkSVGAttrs = merge(svgAttrs('18', '18', '0 0 24 24', checkSVG), staticAttrs);\nexport const switchSVGAttrs = merge(svgAttrs('15', '15', '0 0 20 20', switchSVG), staticAttrs);\n","import { ARROW_DOWN, ARROW_LEFT, ARROW_RIGHT, ARROW_UP, COLOR, FOCUS_CLASSNAME, FOCUS_IN, FOCUS_OUT, KEY_DOWN, MOUSE_DOWN, MOUSE_MOVE, MOUSE_UP, ROOT, TOUCH_CANCEL, TOUCH_END, TOUCH_MOVE, TOUCH_START } from \"../constants\";\nimport { bindEvent } from \"../core/events/EventBinder\";\nimport { createElement, getBounds, setVisibility, updateClass } from \"../utils/dom\"\nimport { Marker } from \"./Marker\";\n\n/**\n * Palette component constants.\n */\nconst PALETTE_CLASSNAME = 'alwan__palette';\nconst OVERLAY_CLASSNAME = 'lw-overlay';\n\n/**\n * Picker palette.\n *\n * @param {Element} parent - Element to append the palette element to.\n * @param {Object} alwan - Alwan instance.\n * @returns {Object}\n */\nexport const Palette = (parent, alwan) => {\n\n    const { _s: colorState, _e: { _emit }} = alwan;\n\n    /**\n     * Palette element.\n     */\n    const el = createElement('', PALETTE_CLASSNAME, parent, { tabindex: '0' });\n\n    /**\n     * Overlay element, used to set focus only on palette,\n     * if marker is moving.\n     */\n    const overlay = createElement('', OVERLAY_CLASSNAME, parent);\n    setVisibility(overlay, false);\n\n    /**\n     * Move marker one step horizontally using the keyboard.\n     */\n    const moveX = {\n        [ARROW_RIGHT]: 1,\n        [ARROW_LEFT]: -1\n    }\n\n    /**\n     * Move marker one step vertically using the keyboard.\n     */\n    const moveY = {\n        [ARROW_UP]: -1,\n        [ARROW_DOWN]: 1\n    }\n\n    /**\n     * Marker component.\n     */\n    const marker = Marker(el);\n\n    /**\n     * Marker Method.\n     */\n    let { _moveTo } = marker;\n\n    /**\n     * Palette dimensions\n     */\n    let WIDTH, HEIGHT;\n\n    /**\n     * Palette event listeners.\n     */\n    let listeners = [];\n\n    /**\n     * Palette bounds.\n     */\n    let bounds;\n\n    /**\n     * State of the marker.\n     */\n    let isDragging = false;\n\n    /**\n     * Marker start moving.\n     *\n     * @param {Event} e - Mousedown or Touchstart events.\n     * @returns {void}\n     */\n    const dragStart = e => {\n        if (e.touches && e.touches.length > 1) {\n            return;\n        }\n        // Save color state.\n        colorState._colorStart();\n        // Cache palette's bounds.\n        bounds = getBounds(el);\n        updateDimensions(bounds);\n        moveAndUpdateColor(e);\n        isDragging = true;\n        // Display overlay.\n        setVisibility(overlay, isDragging);\n        el.focus();\n    }\n\n    /**\n     * Moves the marker.\n     *\n     * @param {Event} e - Mousemove or Touchmove event.\n     * @returns {void}\n     */\n    const dragMove = e => {\n        if (!isDragging || (e.touches && e.touches.length > 1)) {\n            return;\n        }\n        moveAndUpdateColor(e);\n    }\n\n\n    /**\n     * Marker stop moving.\n     *\n     * @param {Event} e - Mouseup or Touchend or touchcancel events.\n     */\n    const dragEnd = e => {\n        if (isDragging) {\n            // Trigger change event if color changes.\n            colorState._triggerChange(el);\n            isDragging = false;\n            // Hide overlay.\n            setVisibility(overlay, isDragging);\n        }\n    }\n\n\n    /**\n     * Updates color and moves marker.\n     *\n     * @param {Number} x - X coordinate.\n     * @param {Number} y - Y coordinate.\n     */\n    const updateColor = (x, y) => {\n        _moveTo(x, y);\n        colorState._update({ s: x / WIDTH, v: 1 - y / HEIGHT });\n        _emit(COLOR, el);\n    }\n\n\n    /**\n     * Moves Marker and Updates color.\n     *\n     * @param {Event} e - Drag start or drag move events.\n     */\n    const moveAndUpdateColor = e => {\n        let { top, left } = bounds;\n        let x, y;\n        let touches = e.touches;\n\n        e.preventDefault();\n\n        if (touches) {\n            e = touches[0];\n        }\n\n        // Calculate the local coordinates,\n        // local to the palette.\n        x = e.clientX - left;\n        y = e.clientY - top;\n\n        // Make sure x and y don't go out of bounds.\n        x = x < 0 ? 0 : x > WIDTH ? WIDTH : x;\n        y = y < 0 ? 0 : y > HEIGHT ? HEIGHT : y;\n\n        updateColor(x, y);\n    }\n\n    /**\n     * Updates palette.\n     *\n     * @param {Object} hsv - HSV color object.\n     */\n    const _setMarkerPosition = hsv => {\n        updateDimensions();\n        _moveTo(hsv.s * WIDTH, (1 - hsv.v) * HEIGHT);\n    }\n\n    /**\n     * Handles palette's focus.\n     *\n     * @param {Event} e - Focusout or Focusin.\n     */\n    const handleFocus = e => {\n        // Update class condition removes class if its false,\n        // add class if true.\n        let cond = false;\n        // If palette lose focus, remove the focus class,\n        // and remove browser keyboard focus.\n        if (e.type === FOCUS_OUT) {\n            el.blur();\n        } else {\n            cond = ! isDragging;\n        }\n\n        updateClass(el, FOCUS_CLASSNAME, cond);\n    }\n\n    /**\n     * Handles picking color using keyboard.\n     *\n     * @param {Event} e - Keydown.\n     */\n    const handleKeyboard = e => {\n\n        // Add focus class.\n        updateClass(el, FOCUS_CLASSNAME, true);\n\n        let key = e.key;\n\n        if (moveX[key] || moveY[key]) {\n            e.preventDefault();\n\n            updateDimensions();\n\n            let {x, y} = marker._getPosition();\n            let markerX = x, markerY = y;\n            // Amount of pixel to move marker horizontally using keyboard.\n            let stepX = WIDTH / 100;\n            // Amount of pixel to move marker vertically using keyboard.\n            let stepY = HEIGHT / 100;\n\n            x += (moveX[key] || 0) * stepX;\n            y += (moveY[key] || 0) * stepY;\n\n            // Make sure x and y don't go out of bounds.\n            x = x > WIDTH ? WIDTH : x < 0 ? 0 : x;\n            y = y > HEIGHT ? HEIGHT : y < 0 ? 0 : y;\n\n            // If the marker changes its position then calculate and set the color.\n            if (x !== markerX || y !== markerY) {\n                updateColor(x, y);\n            }\n        }\n    }\n\n\n    /**\n     * Updates palette's width and height values.\n     *\n     * @param {Object} bounds - Palette's Bounding rect.\n     */\n    const updateDimensions = bounds => {\n        ({ width: WIDTH, height: HEIGHT } = bounds || getBounds(el));\n    }\n\n    /**\n     * Bind events.\n     */\n    bindEvent(listeners, el, [MOUSE_DOWN, TOUCH_START], dragStart);\n    bindEvent(listeners, ROOT, [MOUSE_MOVE, TOUCH_MOVE], dragMove, { passive: false });\n    bindEvent(listeners, ROOT, [MOUSE_UP, TOUCH_END, TOUCH_CANCEL], dragEnd);\n    bindEvent(listeners, el, [FOCUS_OUT, FOCUS_IN], handleFocus);\n    bindEvent(listeners, el, KEY_DOWN, handleKeyboard);\n\n    return {\n        $: el,\n        marker,\n        _setMarkerPosition,\n        e: listeners\n    }\n}","import { createElement, getBounds } from \"../utils/dom\";\n\n\nconst MARKER_CLASSNAME = 'alwan__marker';\n\n/**\n * Palette's marker.\n *\n * @param {HTMLElement} parent - Element to append to.\n * @returns {Object}\n */\nexport const Marker = parent => {\n\n    /**\n     * Marker.\n     */\n    const el = createElement('', MARKER_CLASSNAME, parent);\n\n    /**\n     * Marker dimensions.\n     */\n    const { width, height } = getBounds(el);\n\n    /**\n     * Cache center X coordinate.\n     */\n    let centerX = width / 2;\n\n    /**\n     * Cache center Y coordinate.\n     */\n    let centerY = height / 2;\n\n    /**\n     * Marker X coordinate.\n     */\n    let markerX = 0;\n\n    /**\n     * Marker Y coordinate.\n     */\n    let markerY = 0;\n\n    /**\n     * Moves marker to the x, y coordinates.\n     *\n     * @param {Number} x - X coordinate.\n     * @param {Number} y - Y coordinate.\n     */\n    const _moveTo = (x, y) => {\n        markerX = x;\n        markerY = y;\n        el.style.transform = `translate(${x - centerX}px, ${y - centerY}px)`;\n    }\n\n    /**\n     * Gets marker coordinates.\n     *\n     * @returns {Object}\n     */\n    const _getPosition = () => ({ x: markerX, y: markerY });\n\n\n    return {\n        $: el,\n        _moveTo,\n        _getPosition\n    }\n}","import { HSL_FORMAT, int, max, min, round } from \"../constants\";\nimport { isString } from \"../utils/util\";\n\n/**\n * Convert HSV to RGB.\n *\n * @param {Object} hsv - HSV color object.\n * @returns {Object}\n */\nexport const HSVToRGB = hsv => {\n\n    let H = hsv.h / 60,\n        S = hsv.s,\n        V = hsv.v;\n\n    /**\n     * Helper function used for converting HSV to RGB.\n     *\n     * @param {Number} k - Positive Coefficient.\n     * @param {Number} s - hSV Saturation.\n     * @param {Number} v - HSV Value.\n     * @returns {Number}\n     */\n    let fn = (k, s, v) => (v - v * s * max(0, min(k, 4 - k, 1))) * 255;\n\n    return {\n        r: round(fn((5 + H) % 6, S, V)),\n        g: round(fn((3 + H) % 6, S, V)),\n        b: round(fn((1 + H) % 6, S, V)),\n        a: hsv.a\n    }\n}\n\n\n/**\n * Convert RGB or HSL color objects to string.\n *\n * @param {Object} color  - Color Object.\n * @param {string} format - Color format.\n * @returns {string}\n */\nexport const toString = (color, format) => {\n\n    let colorString = color;\n\n    if (! isString(color)) {\n\n        let a = '',\n            opacity = '',\n            comma = ', ';\n    \n        if (color.a < 1) {\n            a = 'a';\n            opacity = comma + color.a;\n        }\n\n        let percent = format === HSL_FORMAT ? '%' : '';\n        colorString = format + a + '(' + color[format[0]] + comma + color[format[1]] + percent + comma + color[format[2]] + percent + opacity + ')';\n    }\n\n    return colorString;\n}\n\n/**\n * Converts hex color string to RGB color object.\n *\n * @param {string} hexColor - Hexadecimal color string.\n * @returns {Object}\n */\nexport const HEXToRGB = hexColor => ({\n    r: int(hexColor.slice(1, 3), 16),\n    g: int(hexColor.slice(3, 5), 16),\n    b: int(hexColor.slice(5, 7), 16),\n    a: 1\n});\n\n\n/**\n * Converts a decimal number to hexadecimal number.\n * The result must be two digits.\n *\n * @param {Number} number Decimal number.\n * @returns {string}\n */\nconst toHex = number => {\n    let hexNumber = number.toString(16);\n    return hexNumber.length < 2 ? '0' + hexNumber : hexNumber;\n}\n\n\n/**\n * Converts RGB color object to Hex string color.\n *\n * @param {Object} rgb - RGB color object.\n * @returns {String}\n */\nexport const RGBToHEX = ({ r, g, b, a }) => '#' + toHex(r) + toHex(g) + toHex(b) + (a < 1 ? toHex(round(a * 255)) : '');\n\n\n/**\n * Converts HSV to HSL.\n *\n * @param {Object} hsv - HSV color object.\n * @returns {Object}\n */\nexport const HSVToHSL = (hsv, percentage) => {\n\n    percentage = percentage ? '%' : 0;\n\n    let v = hsv.v;\n    let l = v * (1 - hsv.s / 2);\n    let s = ! l || l === 1 ? 0 : (v - l) / min(l, 1 - l);\n\n    return {\n        h: hsv.h,\n        s: round(s * 100) + percentage,\n        l: round(l * 100) + percentage,\n        a: round(hsv.a * 100) / 100\n    }\n}\n\n/**\n * Converts HSL to HSV.\n *\n * @param {Object} hsl - HSL color object.\n * @returns {Object}\n */\nexport const HSLToHSV = (hsl) => {\n    let s = hsl.s / 100,\n        l = hsl.l / 100,\n        v = l + s * min(l, 1 - l);\n\n    return {\n        h: hsl.h,\n        s: v ? 2 * (1 - l / v) : 0,\n        v,\n        a: hsl.a\n    }\n}\n\n\n/**\n * Converts RGB to HSV.\n *\n * @param {Object} rgb - RGB color object.\n * @returns {Object}\n */\nexport const RGBToHSV = rgb => {\n    let R = rgb.r / 255,\n        G = rgb.g / 255,\n        B = rgb.b / 255,\n        Cmax = max(R, G, B),\n        Cmin = min(R, G, B),\n        range = Cmax - Cmin,\n        saturation = Cmax === 0 ? 0 : range / Cmax,\n        hue = range === 0 ? 0\n            : Cmax === R ? ((G - B) / range) % 6\n            : Cmax === G ? ((B - R) / range) + 2\n            : Cmax === B ? ((R - G) / range) + 4\n            : 0;\n\n    return {\n        h: round( ( 360 + hue * 60 ) % 360 ),\n        s: saturation,\n        v: Cmax,\n        a: round( rgb.a * 100 ) / 100\n    }\n}","import { float, HSL_FORMAT, RGB_FORMAT, round } from \"../constants\";\nimport { createElement } from \"../utils/dom\";\nimport { boundNumber, normalizeHue } from \"../utils/util\";\nimport { HEXToRGB, toString } from \"./colors\";\n\nconst ctx = createElement('canvas').getContext('2d');\nconst HSL_REGEX = /^hsla?\\(\\s*([+-]?\\d*\\.?\\d+)(\\w*)?(?:(?:\\s+([+-]?\\d*\\.?\\d+)%\\s*([+-]?\\d*\\.?\\d+)%(?:\\s*\\/\\s*([+-]?\\d*\\.?\\d+%?))?)|(?:\\s*,\\s*([+-]?\\d*\\.?\\d+)%\\s*,\\s*([+-]?\\d*\\.?\\d+)%(?:\\s*,\\s*([+-]?\\d*\\.?\\d+%?))?))\\s*\\)?$/i;\nconst HEX_REGEX = /^#[0-9a-f]{6}$/i;\n\n\n/**\n * Parses a color string.\n *\n * @param {String} colorString - Color string.\n * @param {Boolean} asString - Return color as a string or object.\n * @returns {Object}\n */\nexport const parseColor = (colorString, asString) => {\n\n    let _color;\n    let _format;\n\n    colorString = colorString.trim();\n    /**\n     * Parse hsl.\n     * No need to parse it if it's shorter than the minimum hsl string length,\n     * the minimum is 10 characters, e.g. hsl(0 0%0%.\n     */\n    if (colorString.length >= 10) {\n\n        const channels = colorString.match(HSL_REGEX);\n\n        if (channels) {\n            let h = float(channels[1]),\n                angle = channels[2],\n                s = boundNumber(channels[3] || channels[6]),\n                l = boundNumber(channels[4] || channels[7]),\n                a = channels[5] || channels[8];\n\n            /**\n             * The hue value is so often given in degrees, it can be given as a number, however\n             * it might has a unit 'turn', 'rad' (radians) or 'grad' (gradians),\n             * If the hue has a unit other than deg, then convert it to degrees.\n             */\n            h *= angle === 'turn' ? 360\n                : angle === 'rad' ? 180 / PI\n                : angle === 'grad' ? 0.9\n                : 1;\n\n            // Make sure hue is between 0 and 360.\n            h = normalizeHue(h);\n\n            // Alpha value must be between 0 and 1.\n            a = a ? boundNumber(a.slice(-1) === '%' ? float(a) / 100 : a, 1) : 1;\n\n            _color  = { h, s, l, a };\n            _format = HSL_FORMAT;\n        }\n    }\n\n    // colorString is not an HSL string.\n    if (! _color) {\n\n        ctx.fillStyle = '#000';\n        ctx.fillStyle = colorString;\n        colorString = ctx.fillStyle;\n        // ColorString is either hex or rgb string,\n        // if it's hex convert it to rgb object,\n        // if it's rgb then parse it to object.\n        if (HEX_REGEX.test(colorString)) {\n            _color = HEXToRGB(colorString);\n        } else {\n            // Parse RGB string.\n            let [r, g, b, a] = colorString.match(/\\((.+)\\)/)[1]\n                                          .split(',')\n                                          .map(value => float(value));\n\n            _color = {\n                r,\n                g,\n                b,\n                a: a != null ? round(a * 100) / 100 : 1,\n            }\n        }\n\n        _format = RGB_FORMAT;\n    }\n\n    return asString ? toString(_color, _format) : { _color, _format };\n}","import { App } from \"../components/App\";\nimport { Inputs } from \"../components/Inputs\";\nimport { Palette } from \"../components/Palette\";\nimport { Preview } from \"../components/Preview\";\nimport { Reference } from \"../components/Reference\";\nimport { Sliders } from \"../components/Sliders\";\nimport { Swatches } from \"../components/Swatches\";\nimport { createElement } from \"../utils/dom\";\n\n\nconst CONTAINER_CLASSNAME = 'alwan__container';\n\n/**\n * Create and initialize components.\n *\n * @param {Element} reference - Picker Reference element.\n * @param {Object} alwan - Alwan Instance.\n * @returns {Object}\n */\nexport const createComponents = (reference, alwan) => {\n\n    /**\n     * Creates a container element.\n     *\n     * @param {HTMLElement} parent - Element to append the created container to.\n     * @returns {HTMLElement}\n     */\n    const createContainer = (parent) => createElement('', CONTAINER_CLASSNAME, parent);\n\n\n    let ref = Reference(reference, alwan);\n    let app = App(alwan);\n\n    let root = app.$;\n\n    let palette = Palette(root, alwan);\n\n    let container = createContainer(root);\n    \n    let preview = Preview(container, alwan);\n    let sliders = Sliders(container, alwan);\n    let inputs = Inputs(createContainer(root), alwan);\n    let swatches = Swatches(root, alwan);\n\n    return {\n        ref,\n        app,\n        palette,\n        preview,\n        sliders,\n        inputs,\n        swatches\n    }\n}","import { BUTTON, CLICK } from \"../constants\";\nimport { bindEvent, unbindEvent } from \"../core/events/EventBinder\";\nimport { createElement, replaceElement, setVisibility, updateClass } from \"../utils/dom\";\n\n\nconst PRESET_BUTTON_CLASSNAME = 'lw-ref';\n\n/**\n * Creates a Reference component.\n *\n * @param {Element} originalRef - User Reference Element.\n * @returns {Object}\n */\nexport const Reference = (originalRef, alwan) => {\n\n    /**\n     * Reference API.\n     */\n    const self = {\n        $: originalRef,\n        /**\n         * Reference Events.\n         */\n        e: [],\n        /**\n         * Sets/Unsets the pre-styled button.\n         *\n         * @param {Object} options - Picker options.\n         */\n        _init(options) {\n            let { preset, classname } = options;\n            let { $: ref, e: events } = self;\n\n            events = unbindEvent(events, ref);\n            \n            if (preset !== (ref !== originalRef)) {\n                ref = preset ?\n                        // Replace the user provided reference element with a preset button.\n                        replaceElement( createElement(BUTTON, PRESET_BUTTON_CLASSNAME, null, { type: BUTTON, id: originalRef.id }), originalRef)\n                        // Set back user reference element.\n                        : replaceElement(originalRef, ref);\n            }\n\n            // Add classes in the reference element.\n            if (classname) {\n                classname.split(/\\s+/).map(cls => { updateClass(ref, cls, true) });\n            }\n\n            // Add click event to reference.\n            bindEvent(events, ref, CLICK, togglePicker);\n            self.$ = ref;\n            self.e = events;\n        }\n    }\n\n    /**\n     * Toggle picker.\n     *\n     * @param {Event} e - Click.\n     */\n    const togglePicker = e => {\n        alwan.toggle();\n    }\n\n    return self;\n}","import { BUTTON, BUTTON_CLASSNAME, CLICK, FOCUS_CLASSNAME, FOCUS_IN, FOCUS_OUT, MOUSE_LEAVE, SVG } from \"../constants\";\nimport { bindEvent } from \"../core/events/EventBinder\";\nimport { checkSVGAttrs, clipboardSVGAttrs } from \"../lib/svg\";\nimport { createElement, removeElement, setElementsHTML, setVisibility, updateClass } from \"../utils/dom\";\n\nconst PREVIEW_CLASSNAME = 'alwan__preview';\nconst MARGIN_CLASSNAME = 'lw-mr';\n\n/**\n * Preview component.\n *\n * @param {Element} parent - Element to append preview are to.\n * @param {Object} alwan - Instance.\n * @returns {Object}\n */\nexport const Preview = (parent, alwan) => {\n\n    /**\n     * Copy state.\n     */\n    let isCopied = false;\n\n    /**\n     * Preview area wrapper element.\n     */\n    const container = createElement('', MARGIN_CLASSNAME, parent);\n\n    /**\n     * Preview API.\n     */\n    const self = {\n        /**\n         * Preview events.\n         */\n        e: [],\n\n        /**\n         * Init. Preview, copy button.\n         *\n         * @param {Object} options - Picker options.\n         */\n        _init(options) {\n            let { preview, copy } = options;\n            let previewArea = self.$;\n            let copyButton = self.cp;\n\n            // Either preview option is true and previewArea doen't exist,\n            // or preview option is false and previewArea does exist.\n            if (preview !== !!previewArea) {\n\n                previewArea = preview ? createElement('', PREVIEW_CLASSNAME, container) : removeElement(previewArea, true);\n    \n                if (copy && copyButton) {\n                    (previewArea || container).appendChild(copyButton);\n                }\n            }\n\n            if (! copy) {\n                copyButton = removeElement(copyButton, true);\n            } else if (! copyButton) {\n                copyButton = createElement(BUTTON, BUTTON_CLASSNAME, previewArea || container, { type: BUTTON }, thisButton => {\n                    updateSVG(thisButton);\n                });\n            }\n\n            // Hide container if both copyButton and previewArea don't exist,\n            setVisibility(container, copyButton || previewArea);\n\n            self.$ = previewArea;\n            self.cp = copyButton;\n        }\n    }\n\n\n    /**\n     * Sets a SVG icon for the copy button.\n     *\n     * @param {HTMLElement} button - Button.\n     */\n    const updateSVG = (button) => {\n        button = button || self.cp;\n        // Remove button content.\n        setElementsHTML(button);\n        createElement(SVG, '', button, isCopied ? checkSVGAttrs : clipboardSVGAttrs);\n    }\n\n    /**\n     * Copies selected color to the clipboard then updates copy,\n     * button's Icon and styles.\n     *\n     * @param {Event} e - Click or Focusin or Focusout or Mouseleave.\n     */\n    const copyColorAndUpdateView = e => {\n        if (self.cp && ! alwan.config.disabled) {\n            let type = e.type;\n            let isFocusIn = type === FOCUS_IN;\n\n            // On click copy color and update svg to display a Check icon.\n            if (! isCopied && type === CLICK) {\n                alwan._s._copyColor();\n                isCopied = true;\n                updateSVG();\n            }else {\n                // On focus add a focus class.\n                if (! isFocusIn) {\n                    // If the copy button lose focus or mouse leaves it,\n                    // then reset the svg to a Clipboard icon.\n                    if (isCopied) {\n                        isCopied = false;\n                        updateSVG();\n                    }\n                }\n\n                updateClass(self.cp, FOCUS_CLASSNAME, isFocusIn);\n            }\n        }\n    }\n\n    /**\n     * Events binding.\n     */\n    bindEvent(self.e, container, [CLICK, MOUSE_LEAVE, FOCUS_IN, FOCUS_OUT], copyColorAndUpdateView);\n\n    return self;\n}","import { CHANGE, COLOR, INPUT } from \"../constants\";\nimport { bindEvent } from \"../core/events/EventBinder\";\nimport { createElement, removeElement } from \"../utils/dom\";\n\n/**\n * Sliders component constants.\n */\nconst SLIDER_CLASSNAME = 'alwan__slider';\nconst HUE_SLIDER_CLASSNAME = SLIDER_CLASSNAME + ' ' + SLIDER_CLASSNAME + '--hue';\nconst ALPHA_SLIDER_CLASSNAME = SLIDER_CLASSNAME + ' ' + SLIDER_CLASSNAME + '--alpha'; \nconst WIDTH_CLASSNAME = 'lw-w100';\n\n/**\n * Picker sliders.\n *\n * @param {Element} parent - Element to append sliders to.\n * @param {Object} alwan - Alwan instance.\n * @returns {Object}\n */\nexport const Sliders = (parent, alwan) => {\n\n    /**\n     * Sliders wrapper element.\n     */\n    const container = createElement('', WIDTH_CLASSNAME, parent);\n\n    /**\n     * Color state updater.\n     */\n    const updateColor = alwan._s._update;\n\n    /**\n     * Builds a slider.\n     *\n     * @param {String} className - Slider classname.\n     * @param {Number} max - Slider max value.\n     * @param {Number} step - Slider step.\n     * @returns {HTMLElement}\n     */\n    const build = (className, max, step) => \n         createElement(INPUT, className, container, { type: 'range', max, step });\n \n    /**\n     * Component API.\n     */\n    const self = {\n        /**\n         * Sliders events.\n         */\n        e: [],\n\n        hue: build(HUE_SLIDER_CLASSNAME, 360),\n        alpha: null,\n\n        /**\n         * Init. Sliders.\n         *\n         * @param {Object} options - New options.\n         */\n        _init({ opacity }) {\n\n            let alpha = self.alpha;\n\n            if (opacity !== !!alpha) {\n                self.alpha = opacity ? build(ALPHA_SLIDER_CLASSNAME, 1, 0.01)\n                                     : removeElement(alpha, true) || updateColor({ a: 1 });\n            }\n        },\n\n        /**\n         * Sets sliders values.\n         *\n         * @param {Object} hsv - HSV color object.\n         */\n        _setValue(hsv) {\n            let { alpha, hue } = self;\n            hue.value = 360 - hsv.h;\n            alpha && (alpha.value = hsv.a);\n        }\n    }\n\n    /**\n     * Handles changes in a slider value.\n     *\n     * @param {Event} e - Input or Change event.\n     */\n    const handleChange = e => {\n        let slider = e.target;\n        let value = slider.valueAsNumber;\n        let hsv = {};\n\n        if (slider === self.hue) {\n            hsv.h = 360 - value;\n        } else {\n            hsv.a = value;\n        }\n\n        updateColor(hsv);\n        // Either fire change or color event.\n        alwan._e._emit(e.type === CHANGE ? CHANGE : COLOR, slider);\n    }\n\n    /**\n     * Events binding.\n     */\n    bindEvent(self.e, container, [INPUT, CHANGE], handleChange);\n\n    return self;\n}","import { BUTTON, BUTTON_CLASSNAME, CHANGE, CLICK, COLOR, COLOR_FORMATS, ENTER, FOCUS_IN, HEX_FORMAT, INPUT, KEY_DOWN, max, SVG } from \"../constants\";\nimport { bindEvent } from \"../core/events/EventBinder\";\nimport { switchSVGAttrs } from \"../lib/svg\";\nimport { createElement, removeElement, setElementsHTML, setVisibility } from \"../utils/dom\";\nimport { objectIterator } from \"../utils/object\";\n\n/**\n * Inputs constants.\n */\nconst INPUTS_CLASSNAME = 'alwan__inputs';\nconst INPUT_CLASSNAME = 'alwan__input';\nconst LABEL_CLASSNAME = 'lw-label';\n\n/**\n * Inputs component.\n *\n * @param {Element} parent - Element to append the inputs container element to.\n * @param {Object} alwan - Alwan instance.\n * @returns {Object}\n */\nexport const Inputs = (parent, alwan) => {\n\n    /**\n     * Inputs wrapper element.\n     */\n    let container;\n\n    /**\n     * Switch button.\n     * @type {Element}\n     */\n    let switchButton;\n\n    /**\n     * Picker formats.\n     */\n    let formats = [];\n\n    /**\n     * Index of the current format.\n     */\n    let formatIndex;\n\n    /**\n     * Array of inputs.\n     */\n    let inputList;\n\n    /**\n     * Event listeners.\n     */\n    let listeners = [];\n\n    const { config, _s: colorState, _e: { _emit } } = alwan;\n\n    /**\n     * Component API.\n     */\n    const self = {\n        /**\n         * Init. Inputs.\n         *\n         * @param {Object} options - Options.\n         */\n        _init(options) {\n            let { inputs, format } = options;\n            let length;\n\n            // Get only valid formats.\n            formats = COLOR_FORMATS.filter(format => inputs[format]);\n            length = formats.length;\n\n            if (! length) {\n                // No input, remove inputs.\n                container = removeElement(container, true);\n                switchButton = removeElement(switchButton, true);\n                // Normalize format value.\n                format = COLOR_FORMATS.includes(format) ? format : COLOR_FORMATS[0];\n            } else {\n\n                if (! container) {\n                    container = createElement('', INPUTS_CLASSNAME, parent);\n                }\n\n                if (length === 1) {\n                    switchButton = removeElement(switchButton, true);\n                } else if (!switchButton) {\n                    // For more than one input format, add a switch button.\n                    switchButton = createElement(BUTTON, BUTTON_CLASSNAME, parent, { type: BUTTON }, (thisButton) => {\n                        createElement(SVG, '', thisButton, switchSVGAttrs);\n                    });\n                }\n\n                formatIndex = max(formats.indexOf(format), 0);\n                format = formats[formatIndex];\n            }\n            config.format = format;\n            build(format);\n            // Show/Hide parent container.\n            setVisibility(parent, length);\n        },\n\n        /**\n         * Updates Input(s) value(s).\n         *\n         * @param {Object} color - Color object.\n         */\n        _setValue(color) {\n            objectIterator(self.$, (input, key) => {\n                input.value = color[key];\n            });\n        }\n    }\n\n    /**\n     * Build Inputs.\n     */\n    const build = (format) => {\n\n        self.$ = {};\n        inputList = [];\n\n        if (container) {\n            let { singleInput, opacity } = config;\n            // Each letter in the format variable represent a color channel,\n            // For multiple inputs, each color channel has an input field.\n            // e.g. for 'rgb' format fields array is [r, g, b] or [r, g, b, a] if opacity is true.\n            let fields = singleInput || format == HEX_FORMAT ? [format]\n                        : (format + (opacity ? 'a' : '')).split('');\n\n            // Empty the container from any inputs.\n            setElementsHTML(container);\n\n            fields.forEach((field, index) => {\n                /**\n                 * Create Input.\n                 * \n                 * <label class=\"sc-label\">\n                 *     <input type=\"text\" class=\"sc-picker__input\">\n                 *     <span>${field}</span>\n                 * </label>\n                 */\n                createElement('label', LABEL_CLASSNAME, container, false, (label => {\n                    self.$[field] = inputList[index] = createElement(INPUT, INPUT_CLASSNAME, label, { type: 'text' });\n                    createElement('span', '', label, { text: field });\n                }));\n            });\n\n            colorState._update({});\n        }\n    }\n\n    /**\n     * Handles changes in inputs.\n     *\n     * @param {Event} e - Input event.\n     */\n    const handleChange = e => {\n        let value = e.target.value;\n\n        if (value.trim()) {\n            let colorString = '';\n            let format = formats[formatIndex];\n            \n            if (config.singleInput || format === HEX_FORMAT) {\n                colorString = value;\n            } else {\n                // InputList has 3 or 4 inputs, Input for each color channel in the hsl and rgb,\n                // format, the reduce method adds comma between each input value.\n                // [30, 20, 10, 0.5] => '30,20,10,0.5'\n                colorString = format + '(' + inputList.reduce((string, currentInput) => (string && string + ',') + currentInput.value, '') + ')';\n            }\n\n            if (colorState._updateFromString(colorString, self)) {\n                _emit(COLOR, self.$);\n            }\n        }\n    }\n\n    /**\n     * Changes color format.\n     *\n     * @param {Event} e - Click event.\n     */\n    const changeFormat = e => {\n        if (e.target === switchButton) {\n            // Increment input format index, reset it if it reaches the end.\n            // this index will point to the next format.\n            formatIndex = (formatIndex + 1) % formats.length;\n            config.format = formats[formatIndex];\n            build(formats[formatIndex]);\n        }\n    }\n\n    /**\n     * Triggers change event when the color changes.\n     *\n     * @param {Event} e - Focusin or Change.\n     */\n    const triggerChangeEvent = e => {\n        if (e.type === FOCUS_IN) {\n            // Save color state, when inputs receive focus.\n            colorState._colorStart();\n        } else {\n            // Trigger change event if color state is changed.\n            colorState._triggerChange(self.$);\n        }\n    }\n\n    /**\n     * Closes picker.\n     *\n     * @param {Event} e - Keydown.\n     */\n    const closePicker = e => {\n        if (e.key === ENTER) {\n            alwan.close();\n        }\n    }\n\n    /**\n     * Bind events.\n     */\n    bindEvent(listeners, parent, CLICK, changeFormat);\n    bindEvent(listeners, parent, INPUT, handleChange);\n    bindEvent(listeners, parent, [FOCUS_IN, CHANGE], triggerChangeEvent);\n    bindEvent(listeners, parent, KEY_DOWN, closePicker);\n\n    self.e = listeners;\n\n    return self;\n}","import { BUTTON, CLICK, COLOR_PROPERTY, int } from \"../constants\";\nimport { bindEvent } from \"../core/events/EventBinder\";\nimport { parseColor } from \"../lib/parser\";\nimport { createElement, getParent, removeElement, setCustomProperty, setElementsHTML, setVisibility } from \"../utils/dom\";\nimport { setColorAndTriggerEvents } from \"../utils/util\";\n\n/**\n * Swatches constants.\n */\nconst SWATCHES_CLASSNAME = 'alwan__swatches';\nconst SWATCHE_CLASSNAME = 'alwan__swatch';\n\n/**\n * Swatches component.\n *\n * @param {Element} parent - Element to append the palette element to.\n * @param {Object} alwan - Picker Instance.\n * @returns {Object}\n */\nexport const Swatches = (parent, alwan) => {\n\n    /**\n     * Buttons wrapper element.\n     */\n    let container = createElement('', SWATCHES_CLASSNAME, parent);\n\n    /**\n     * Swatches array.\n     */\n    let swatches;\n\n    /**\n     * Creates a swatch button.\n     *\n     * @param {String} color - Swatch Color.\n     * @returns {Element}\n     */\n    const createSwatchButton = color => createElement(BUTTON, SWATCHE_CLASSNAME, container, {\n            type: BUTTON,\n        }, button => { setCustomProperty(button, COLOR_PROPERTY, parseColor(color, true)) });\n\n    /**\n     * Swatches API.\n     */\n    const self = {\n        /**\n         * Swatches events.\n         */\n        e: [],\n\n        /**\n         * Initialize swatches.\n         *\n         * @param {Object} options - Alwan options.\n         */\n        _init(options) {\n            let buttons = [];\n            swatches = options.swatches;\n    \n            setVisibility(container, swatches);\n            // Empty the container from all swatch buttons.\n            setElementsHTML(container);\n    \n            swatches.forEach((color, index) => {\n                buttons[index] = createSwatchButton(color);\n            });\n\n            self.$ = buttons;\n        },\n        /**\n         * Adds a swatch button.\n         *\n         * @param {String} color - Color.\n         */\n        _add(color) {\n            let index = swatches.push(color) - 1;\n            self.$[index] = createSwatchButton(color);\n    \n            // If swatches array is empty, hide container.\n            setVisibility(container, swatches);\n        },\n        /**\n         * Removes a swatch button.\n         *\n         * @param {String|Number} swatch - Color or Swatch Index.\n         */\n        _remove(swatch) {\n            let index = swatches.findIndex((color, index) => swatch === color || int(swatch) === index);\n            let swatchButtons = self.$;\n\n            if (index > -1) {\n                // Remove color from swatches array.\n                swatches.splice(index, 1);\n                // Remove swatch button.\n                removeElement(swatchButtons[index]);\n                swatchButtons.splice(index, 1);\n\n                // If swatches array is empty then hide the container.\n                setVisibility(container, swatches);\n            }\n        }\n    };\n\n    /**\n     * Sets color from a swatch button.\n     *\n     * @param {Event} e - Click.\n     */\n    const setColorFromSwatch = e => {\n        let target = e.target;\n\n        if (getParent(target) === container) {\n            setColorAndTriggerEvents(alwan, target.style.getPropertyValue('--' + COLOR_PROPERTY), target);\n        }\n    }\n\n    /**\n     * Bind events.\n     */\n    bindEvent(self.e, parent, CLICK, setColorFromSwatch);\n\n    return self;\n}","import { CHANGE, COLOR_PROPERTY, HEX_FORMAT, HSL_FORMAT, HSV_FORMAT, HTML, INPUT, RGB_FORMAT, ROOT } from \"../constants\";\nimport { HSLToHSV, HSVToHSL, HSVToRGB, RGBToHEX, RGBToHSV, toString } from \"../lib/colors\";\nimport { parseColor } from \"../lib/parser\";\nimport { createElement, removeElement, setCustomProperty } from \"../utils/dom\";\nimport { isEqual, merge, objectIterator } from \"../utils/object\";\nimport { isset, isString } from \"../utils/util\";\n\n/**\n * Color state.\n *\n * @param {Object} alwan - Alwan instance.\n * @returns {Object}\n */\nexport const ColorState = (alwan) => {\n\n    /**\n     * HSV color object.\n     */\n    let HSV = {\n        h: 0,\n        s: 0,\n        v: 0,\n        a: 1\n    }\n\n    /**\n     * RGB color object.\n     */\n    let RGB = HSVToRGB(HSV);\n\n    /**\n     * RGB string.\n     */\n    let rgbString = '';\n\n    /**\n     * Color object used for detecting a color change.\n     */\n    let colorStart;\n\n    \n    let { config, _e: event } = alwan;\n\n    /**\n     * Gets color object.\n     *\n     * @param {String} format - Color format.\n     * @param {Boolean} asString - Get color as a string.\n     * @returns {Object}\n     */\n    const getColorByFormat = (format, asString) => {\n        format = format || config.format;\n\n        let isHex = format === HEX_FORMAT;\n        let color = isHex ? RGBToHEX(RGB)\n                : format === HSL_FORMAT ? HSVToHSL(HSV, !asString)\n                : RGB;\n\n        return asString || isHex ? { [format]: toString(color, format) } : color;\n    }\n\n    /**\n     * Outputs a color object.\n     *\n     * @param {Object} colorObject - RGB, HSL or HSV color object.\n     * @param {String} colorString - Color string.\n     * @param {String} format - Color format.\n     * @param {Boolean} asArray - Output color values in an array.\n     * @returns {Ojbect|Array}\n     */\n    const output = (colorObject, colorString, format, asArray) => {\n        if (config.opacity) {\n            format += 'a';\n        }\n\n        let output = asArray ? [] : {};\n\n        if (format !== HSV_FORMAT) {\n            output.toString = () => colorString || toString(colorObject, format);\n        }\n\n        /**\n         * This puts colorObject values in an object or an array.\n         *\n         * @param {Object|Array} color - The output color.\n         * @param {String} channel - Color channel.\n         * @param {index} index - Array index.\n         */\n        return format.split('').reduce((color, channel, index) => {\n\n            color[asArray ? index : channel] = colorObject[channel];\n\n            return color;\n\n        }, output);\n    }\n\n    return {\n        /**\n         * Updates color and UI.\n         *\n         * @param {Object} newHSV - HSV color object.\n         * @param {Object|Boolean} updater - Exclude some components from updating.\n         * @param {Object} rgb - RGB color object.\n         */\n        _update(newHSV, updater, rgb) {\n            if (! config.disabled) {\n                merge(HSV, newHSV);\n                RGB = rgb || HSVToRGB(HSV);\n                rgbString = toString(RGB, RGB_FORMAT);\n        \n                let components = alwan._c;\n                let { palette, sliders, inputs } = components;\n        \n                // Preview color.\n                setCustomProperty(components.preview.$, COLOR_PROPERTY, rgbString);\n                setCustomProperty(components.ref.$, COLOR_PROPERTY, rgbString);\n                // Change the gradient color stop of the alpha slider.\n                (updater || ! isset(newHSV.a)) && setCustomProperty(sliders.alpha, RGB_FORMAT, RGB.r + ',' + RGB.g + ',' + RGB.b);\n                // Set palette's hue.\n                isset(newHSV.h) && setCustomProperty(palette.$, 'hue', HSV.h);\n    \n                if (updater !== inputs) {\n                    inputs._setValue( getColorByFormat('', config.singleInput) );\n                }\n    \n                if (updater) {\n                    sliders._setValue(HSV);\n                    palette._setMarkerPosition(HSV);\n                }\n            }\n        },\n\n         /**\n         * Updates color by a string instead of HSV object.\n         *\n         * @param {String} colorString - Color string.\n         * @param {Boolean|Object} updater - Exclude some components from updating.\n         */\n        _updateFromString(colorString, updater) {\n            if (isString(colorString)) {\n                let { _color: parsedColor, _format: format } = parseColor(colorString);\n                let currentColor = getColorByFormat(format);\n                let isChanged = ! isEqual(parsedColor, currentColor);\n                let rgb, hsv;\n    \n                if (isChanged) {\n    \n                    if (format === HSL_FORMAT) {\n                        hsv = HSLToHSV(parsedColor);\n                    } else {\n                        rgb = parsedColor;\n                        hsv = RGBToHSV(parsedColor);\n                    }\n    \n                    this._update(hsv, updater, rgb);\n                }\n    \n                return isChanged;\n            }\n        },\n\n        /**\n         * Copies color to the clipboard.\n         *\n         * @returns {Boolean}\n         */\n        _copyColor() {\n            objectIterator(getColorByFormat('', true), color => {\n                let clipboard = navigator.clipboard;\n        \n                if (clipboard) {\n                    clipboard.writeText(color);\n                } else {\n                    // Incase browser doesn't support navigator.clipboard,\n                    // Create a new input element and append it to the body,\n                    // set its value as the color.\n                    createElement(INPUT, '', HTML, null, input => {\n        \n                        input.value = color;\n                        input.select();\n                        ROOT.execCommand('copy');\n        \n                        // Color text is copied so remove the input.\n                        removeElement(input);\n                    });\n                }\n            });\n        },\n\n        /**\n         * Picker value.\n         */\n        _colorOutput: {\n            [HSV_FORMAT]: () => output(HSV, '', HSV_FORMAT, false),\n            [RGB_FORMAT]: asArray => output(RGB, rgbString, RGB_FORMAT, asArray),\n            [HSL_FORMAT]: asArray => output(HSVToHSL(HSV), '', HSL_FORMAT, asArray),\n            [HEX_FORMAT]: () => RGBToHEX(RGB)\n        },\n        \n        /**\n         * Set color start.\n         */\n        _colorStart() {\n            colorStart = getColorByFormat();\n        },\n\n        /**\n         * Triggers change event if colorStart doesn't equal to the current color.\n         *\n         * @param {Element} source - Element that changed color state.\n         */\n        _triggerChange(source) {\n            if (! isEqual(colorStart, getColorByFormat())) {\n                event._emit(CHANGE, source);\n            }\n        }\n    }\n}","\nimport { getElement, removeElement } from \"./utils/dom\";\nimport { merge, objectIterator } from \"./utils/object\";\nimport { defaults } from \"./defaults\";\nimport { createComponents } from \"./core\";\nimport { ColorState } from \"./core/colorState\";\nimport { boundNumber, isString, normalizeHue, setColorAndTriggerEvents } from \"./utils/util\";\nimport { HEX_FORMAT, HSL_FORMAT, HSV_FORMAT, RGB_FORMAT } from \"./constants\";\nimport { HSVToHSL, HSVToRGB, RGBToHEX, toString } from \"./lib/colors\";\nimport { EventListener } from \"./core/events/EventListener\";\nimport { binder } from \"./core/events/EventBinder\";\nimport '../sass/alwan.scss';\n\n\nexport default class Alwan {\n\n    static version = VERSION;\n\n    /**\n     * Alwan defaults.\n     */\n    static defaults = defaults;\n\n    /**\n     * Alwan instance constructor.\n     *\n     * @param {String|Element} reference - The reference element.\n     * @param {Object} options - Options.\n     */\n    constructor(reference, options) {\n\n        const alwan = this;\n\n        reference = getElement(reference);\n\n        /**\n         * Settings.\n         */\n        alwan.config = merge({}, Alwan.defaults, options);\n\n        /**\n         * Event Listeners.\n         */\n        alwan._e = EventListener(alwan);\n\n        /**\n         * Color state.\n         */\n        alwan._s = ColorState(alwan);\n\n        /**\n         * Components.\n         */\n        alwan._c = createComponents(reference, alwan);\n\n        /**\n         * Initialize components.\n         */\n        alwan._c.app._setup(alwan.config);\n    }\n\n    /**\n     * Sets new options.\n     *\n     * @param {Object} options - Alwan options.\n     */\n    setOptions(options) {\n        this._c.app._setup(options);\n    }\n\n    /**\n     * Gets the state of the picker whether it's opened or closed.\n     *\n     * @returns {Boolean}\n     */\n    isOpen() {\n        return this._c.app._isOpen();\n    }\n\n    /**\n     * Opens the picker.\n     */\n    open() {\n        this._c.app._open();\n    }\n\n    /**\n     * Closes the picker.\n     */\n    close() {\n        this._c.app._close();\n    }\n\n    /**\n     * Toggles (opens/closes) the picker.\n     */\n    toggle() {\n        this._c.app._toggle();\n    }\n\n    /**\n     * Attaches an event handler function for an event.\n     *\n     * @param {String} type - Event type.\n     * @param {CallableFunction} handler - Event handler.\n     */\n    on(type, handler) {\n        this._e._on(type, handler);\n    }\n\n    /**\n     * Detaches one or more event handlers.\n     *\n     * Note:\n     * omitting handler, remove all handlers from the event,\n     * omitting both event type and handler, remove all handlers that are,\n     * attached to all events.\n     *\n     * @param {String} type - Event type.\n     * @param {CallableFunction} handler - Event handler.\n     */\n    off(type, handler) {\n        this._e._off(type, handler);\n    }\n\n    /**\n     * Sets a color.\n     *\n     * @param {String|Object} color - Color.\n     */\n    setColor(color) {\n\n        let alwan = this;\n        let format;\n\n        if (! isString(color)) {\n            // Get color format from color object.\n            format = [RGB_FORMAT, HSL_FORMAT, HSV_FORMAT].find(format => format.split('')\n                                                                               .every(channel => ! isNaN(color[channel]) && color[channel] !== ''));\n            if (format) {\n                if (color.a == null) {\n                    color.a = 1;\n                }\n\n                if (format === HSV_FORMAT) {\n                    alwan._s._update({\n                        h: normalizeHue(color.h),\n                        s: boundNumber(color.s) / 100,\n                        v: boundNumber(color.v) / 100,\n                        a: color.a\n                    }, true);\n                } else {\n                    color = toString(color, format);\n                }\n            }\n        }\n\n        alwan._s._updateFromString(color, true);\n\n        return alwan;\n    }\n\n    /**\n     * Gets color.\n     *\n     * @returns {Object}\n     */\n    getColor() {\n        return this._s._colorOutput;\n    }\n\n    /**\n     * Adds a swatch.\n     *\n     * @param {String} color - Color.\n     */\n    addSwatch(color) {\n        this._c.swatches._add(color);\n    }\n\n    /**\n     * Removes a swatch.\n     *\n     * @param {String|Number} swatch - Can a color string or it's index in the swatches array.\n     */\n    removeSwatch(swatch) {\n        this._c.swatches._remove(swatch);\n    }\n\n    /**\n     * Enables picker.\n     */\n    enable() {\n        this._c.app._setDisable(false);\n    }\n\n    /**\n     * Disables picker.\n     */\n    disable() {\n        this._c.app._setDisable(true);\n    }\n\n    /**\n     * Resets to default color.\n     */\n    reset() {\n        setColorAndTriggerEvents(this, this.config.default);\n    }\n\n    /**\n     * Repositions picker if it's displayed as a popover.\n     */\n    reposition() {\n        this._c.app._reposition();\n    }\n\n    /**\n     * Executes all handlers attached to the specified event.\n     *\n     * @param {String} type - Event type.\n     */\n    trigger(type) {\n        this._e._emit(type);\n    }\n\n    /**\n     * Destroy picker and free up memory.\n     */\n    destroy() {\n\n        let alwan = this;\n        let components = alwan._c;\n\n        // Initialize the reference element back.\n        components.ref._init({ preset: false });\n\n        // Remove root element from the dom.\n        removeElement(components.app.$);\n\n        // Remove all events.\n        objectIterator(components, components => {\n            components.e.forEach(listener => {\n                binder(listener, true);\n            });\n        });\n\n        // Remove all properties of this instance.\n        objectIterator(alwan, (value, key) => {\n            delete alwan[key];\n        });\n\n        // Empty instance prototype.\n        Object.setPrototypeOf(alwan, Object.prototype);\n    }\n}","import { CHANGE, CLOSE, COLOR, OPEN } from \"../../constants\";\nimport { objectIterator } from \"../../utils/object\";\n\n/**\n * Picker Events.\n *\n * @returns {Object}\n */\nexport const EventListener = (alwan) => {\n\n    /**\n     * Picker event listeners.\n     */\n    const listeners = {\n        [OPEN]: [],\n        [CLOSE]: [],\n        [CHANGE]: [],\n        [COLOR]: []\n    }\n\n    return {\n        /**\n         * Emits an event.\n         *\n         * @param {String} type - Event type.\n         * @param  {Element|Object} source - Event Source.\n         */\n        _emit: (type, source) => {\n            if (! alwan.config.disabled && listeners[type]) {\n                listeners[type].forEach(handler => {\n                    if (type === COLOR || type === CHANGE) {\n                        handler(alwan._s._colorOutput, source || alwan);\n                    } else {\n                        handler();\n                    }\n                });\n            }\n        },\n\n        /**\n         * Adds an event listener.\n         *\n         * @param {String} type - Event type.\n         * @param {CallableFunction} handler - Event handler.\n         */\n        _on: (type, handler) => {\n            listeners[type] && listeners[type].push(handler);\n        },\n\n        /**\n         * Remove event listener(s).\n         *\n         * @param {String} type - Event type.\n         * @param {CallableFunction} handler - Event handler.\n         */\n        _off: (type, handler) => {\n            let handlersArray = listeners[type];\n\n            if (handlersArray) {\n                // Remove the handler if it's specified,\n                // Remove all handlers of this event if handler is omitted.\n                listeners[type] = handler ? handlersArray.filter(attachedHandler => attachedHandler !== handler) : [];\n            } else if (type == null) {\n                objectIterator(listeners, (handlers, type) => {\n                    listeners[type] = [];\n                });\n            }\n        }\n    }\n}","/**\n * SC Picker default options.\n */\n export const defaults = {\n    // Set the container's (widget) id.\n    id: '',\n\n    // One or many classes separated by a white space,\n    // to add it to the preset button.\n    classname: '',\n\n    // Choose a theme, 'dark' or 'light'.\n    theme: 'light',\n\n    // Toggle picker's visibility (Show/Hide),\n    // Setting this to false keeps the picker visible.\n    toggle: true,\n\n    // Display the picker container as a pop-up (a box that floats on top of the page content),\n    // if it's false, picker container will be displayed as a block (embeded in the page's content).\n    popover: true,\n\n    // Set the position of the popper (if popover is set to true) relative to the reference element,\n    // the position has two values seperated by a dash (-),\n    // the first value is the direction (top, bottom, right, left),\n    // the second value is the alignment (start, center, end), omitting this value will default to center.\n    // e.g. 'bottom-start': 'bottom' places the picker below the reference element,\n    // and 'start' aligns the left side of the container with the left side of the reference element.\n    // Note: \n    // If the picker container has no space to be placed, it will auto-position itself.\n    // based on the available space.\n    position: 'bottom-start',\n\n    // Set the gap (in pixels) between the picker container and the reference element.\n    margin: 8,\n\n    // Replace the reference element with a pre-styled button.\n    preset: true,\n\n    // Initial color.\n    color: '#000',\n\n    // Default color.\n    default: '#000',\n\n    // Target can be a selector or an HTML element,\n    // If the option popover is true, the picker container will be positionned retalive to this element,\n    // instead of the reference element.\n    // else if popover option is false, the picker container will be appended as a child into this element.\n    target: '',\n\n    // Disable the picker, users won't be able to pick colors.\n    disabled: false,\n\n    // Initial color format.\n    format: 'rgb',\n\n    // For the formats 'hsl' and 'rgb', choose a single input to display the color string,\n    // or if false, display an input for each color channel.\n    singleInput: false,\n\n    // Choose color formats for the picker input, 'hsl', 'rgb' or 'hex',\n    // No input will be displayed if the array is empty.\n    inputs: {\n        rgb: true,\n        hex: true,\n        hsl: true,\n    },\n\n    // Support alpha channel and display opacity slider.\n    opacity: true,\n\n    // Preview the color.\n    preview: true,\n\n    // Add/Remove a copy button.\n    copy: true,\n\n    // Array of color strings, invalid color strings will default to rgb(0,0,0).\n    swatches: [],\n}"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","ROOT","document","HTML","documentElement","BUTTON","SVG","OPEN","CLOSE","COLOR","CLICK","MOUSE_DOWN","SCROLL","KEY_DOWN","INPUT","CHANGE","FOCUS_IN","FOCUS_OUT","HEX_FORMAT","RGB_FORMAT","HSL_FORMAT","HSV_FORMAT","FOCUS_CLASSNAME","BUTTON_CLASSNAME","COLOR_PROPERTY","REMOVE_METHOD","COLOR_FORMATS","max","min","round","abs","Math","float","parseFloat","int","parseInt","objectIterator","object","fn","merge","target","sources","assign","isEqual","object1","object2","value","isString","isset","boundNumber","number","upperBound","lowerBound","setColorAndTriggerEvents","alwan","color","source","_s","_updateFromString","emit","_e","_emit","normalizeHue","hue","getElement","ref","context","all","Element","createElement","tagName","className","parent","data","callback","ns","element","createElementNS","setElementsHTML","innerText","setAttributeNS","appendChild","getBounds","el","getBoundingClientRect","getParent","parentElement","replaceElement","newChild","oldChild","replaceChild","removeElement","destroy","removeChild","setCustomProperty","property","style","setProperty","setVisibility","cond","length","display","updateClass","classname","classList","html","innerHTML","binder","eventData","unbind","method","targetElement","events","handler","options","forEach","event","bindEvent","listeners","push","unbindEvent","filter","TOP","RIGHT","BOTTOM","LEFT","START","CENTER","END","WIDTH","HEIGHT","App","reference","popper","lastFocusableElement","config","colorState","body","e","isOpen","scrollableAncestors","updatePopper","_reposition","every","scrollable","isVisible","top","elTop","bottom","elBottom","scrollableTop","scrollableBottom","_close","popperEvents","eventBinder","window","handlesAccessibility","elementToFocus","type","shiftKey","palette","_c","$","contains","preventDefault","focus","_update","_open","silent","disabled","toggle","_setDisable","state","_setup","targetReference","theme","popover","position","margin","id","component","init","_init","dataset","pop","domBounds","refBoundingRect","popBoundingRect","side","alignment","split","sides","alignments","setPosition","isVertical","centerPopElement","dimension","maxBoundary","left","right","clientWidth","clientHeight","some","domBoundary","refBound","space","hasSpace","refLowerBound","refUpperBound","lowerSpace","upperSpace","refDimension","popDimension","offset","placement","Popper","scrollableElements","overflow","getComputedStyle","getScrollableAncestors","insertAdjacentElement","_isOpen","_toggle","staticAttrs","focusable","svgAttrs","width","height","viewBox","clipboardSVGAttrs","checkSVGAttrs","switchSVGAttrs","Palette","tabindex","overlay","moveX","moveY","marker","centerX","centerY","markerX","markerY","_moveTo","x","y","transform","_getPosition","Marker","bounds","isDragging","updateColor","s","v","moveAndUpdateColor","touches","clientX","clientY","updateDimensions","_colorStart","passive","_triggerChange","blur","_setMarkerPosition","hsv","HSVToRGB","H","h","S","V","k","r","g","b","a","toString","format","colorString","opacity","comma","percent","toHex","hexNumber","RGBToHEX","HSVToHSL","percentage","l","ctx","getContext","HSL_REGEX","HEX_REGEX","parseColor","asString","_color","_format","trim","channels","match","angle","PI","slice","fillStyle","test","hexColor","map","createComponents","createContainer","originalRef","preset","cls","togglePicker","Reference","app","container","preview","isCopied","copy","previewArea","copyButton","cp","thisButton","updateSVG","button","isFocusIn","_copyColor","Preview","sliders","build","step","SLIDER_CLASSNAME","alpha","_setValue","slider","valueAsNumber","Sliders","inputs","switchButton","formatIndex","inputList","formats","indexOf","includes","input","singleInput","fields","field","index","label","text","reduce","string","currentInput","close","Inputs","swatches","createSwatchButton","buttons","_add","_remove","swatch","findIndex","swatchButtons","splice","getPropertyValue","Swatches","ColorState","colorStart","HSV","RGB","rgbString","getColorByFormat","isHex","output","colorObject","asArray","channel","newHSV","updater","rgb","components","parsedColor","currentColor","isChanged","hsl","HSLToHSV","R","G","B","Cmax","range","saturation","RGBToHSV","this","clipboard","navigator","writeText","select","execCommand","_colorOutput","Alwan","constructor","defaults","_on","_off","handlersArray","attachedHandler","handlers","EventListener","setOptions","open","on","off","setColor","find","isNaN","getColor","addSwatch","removeSwatch","enable","disable","reset","default","reposition","trigger","listener","setPrototypeOf","VERSION","hex"],"sourceRoot":""}